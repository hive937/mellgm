<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Mini Runner</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: Arial, sans-serif;
  }

  #game {
    position: absolute;
    inset: 0;
    display: block;
    width: 100%;
    height: 100%;
    background: #fff;
  }

  .info {
    position: absolute;
    top: 10px;
    left: 0;
    width: 100%;
    text-align: center;
    z-index: 10;
    color: #000;
    font-size: 14px;
    background: rgba(255,255,255,0.7);
    padding: 6px 0;
  }

  .menu {
    position: absolute;
    inset: 0;
    background: linear-gradient(180deg, #b5e0ff, #f0f0f0);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 20;
    text-align: center;
  }

  .menu h1 {
    font-size: 40px;
    color: #222;
    margin-bottom: 30px;
  }

  .menu button {
    padding: 12px 24px;
    font-size: 18px;
    border: none;
    border-radius: 10px;
    background: #0078ff;
    color: white;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    transition: 0.2s;
  }

  .menu button:hover { background: #005fd1; }

  button#restart {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
  }
</style>
</head>
<body>
  <div class="info">
    <span>–ù–∞–∂–º–∏ –ø—Ä–æ–±–µ–ª –∏–ª–∏ —Ç–∞–ø–Ω–∏, —á—Ç–æ–±—ã –ø—Ä—ã–≥–Ω—É—Ç—å –∏ –ª–æ–≤–∏—Ç—å –ø—Ä–µ–¥–º–µ—Ç—ã!</span>
    <button id="restart" style="display:none;">–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å</button>
  </div>

  <div id="mainMenu" class="menu">
    <h1>üèÉ‚Äç‚ôÇÔ∏è Mini Runner</h1>
    <button id="startGame">‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç</button>
  </div>

  <canvas id="game"></canvas>

<script>
  const tg = window.Telegram?.WebApp;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const mainMenu = document.getElementById('mainMenu');
  const startButton = document.getElementById('startGame');
  const restartButton = document.getElementById('restart');

  let gameStarted = false;

  function resize() {
    const vw = window.visualViewport?.width || window.innerWidth;
    const vh = window.visualViewport?.height || window.innerHeight;
    if (vh < 100) return;
    canvas.width = vw;
    canvas.height = vh;
  }

  window.addEventListener('resize', resize);
  window.visualViewport?.addEventListener('resize', resize);

  if (tg) {
    tg.ready();
    tg.expand();
    tg.setBackgroundColor('#ffffff');
    tg.setHeaderColor('#f0f0f0');
    tg.onEvent('viewportChanged', resize);
  }

  setTimeout(resize, 300);
  setTimeout(resize, 1000);

  // === –°–ü–†–ê–ô–¢–´ ===
  const bgImage = Object.assign(new Image(), { src: 'bg1.png' });

  const playerFrames = [
    Object.assign(new Image(), { src: 'player1.png' }),
    Object.assign(new Image(), { src: 'player2.png' })
  ];

  const itemSprites = [
    Object.assign(new Image(), { src: 'item1.png' }),
    Object.assign(new Image(), { src: 'item2.png' }),
    Object.assign(new Image(), { src: 'item3.png' }),
    Object.assign(new Image(), { src: 'item4.png' })
  ];

  let player = { x: 50, y: 0, size: 60, vy: 0, jumpPower: -14, onGround: false };
  let gravity = 0.8;
  let groundY = 0;
  let obstacles = [];
  let items = [];
  let score = 0;
  let gameOver = false;
  let speed = 6;
  let spawnTimer = 0;
  let itemTimer = 0;
  const jumpHeight = (player.jumpPower ** 2) / (2 * gravity);
  let currentFrame = 0;
  let frameTimer = 0;
  const frameDelay = 10;

  // === —Ñ–æ–Ω ===
  let bgX = 0;
  const bgSpeedFactor = 0.5; // 0.5 ‚Äî —Ñ–æ–Ω –¥–≤–∏–∂–µ—Ç—Å—è –º–µ–¥–ª–µ–Ω–Ω–µ–µ (–ø–∞—Ä–∞–ª–ª–∞–∫—Å)

  // === —Å–º–µ—Ä—Ç—å –∏ –º–∏–≥–∞–Ω–∏–µ ===
  let deathAnimation = false;
  let deathTimer = 0;
  let blinkState = true;

  function updateGround() {
    groundY = canvas.height / 2 + 100;
  }

  function spawnObstacle() {
    const h = 30 + Math.random() * 50;
    obstacles.push({ x: canvas.width + 10, y: groundY - h, w: 20 + Math.random() * 20, h });
  }

  function spawnItem() {
    const size = 40;
    const minHeightAboveGround = 40;
    const maxHeightAboveGround = Math.max(60, jumpHeight - 20);
    const y = groundY - (minHeightAboveGround + Math.random() * (maxHeightAboveGround - minHeightAboveGround));
    const spriteIndex = Math.floor(Math.random() * itemSprites.length);
    items.push({
      x: canvas.width + 10,
      y,
      baseY: y,
      size,
      spriteIndex,
      caught: false,
      phase: Math.random() * Math.PI * 2
    });
  }

  function jump() {
    if (player.onGround && !gameOver) {
      player.vy = player.jumpPower;
      player.onGround = false;
    }
  }

  document.addEventListener('keydown', e => {
    if (!gameStarted && e.code === 'Space') startGame();
    if (e.code === 'Space') {
      e.preventDefault();
      if (!gameOver && gameStarted && !deathAnimation) jump();
    }
    if (e.code === 'Enter' && gameOver) restart();
  });

  canvas.addEventListener('touchstart', e => { 
    e.preventDefault(); 
    if (!gameStarted) startGame();
    else if (!deathAnimation) jump();
  }, { passive: false });

  canvas.addEventListener('mousedown', e => {
    if (!gameStarted) startGame();
    else if (!deathAnimation) jump();
  });

  function update() {
    if (!gameStarted || gameOver || canvas.height < 100) return;

    // —Å–º–µ—Ä—Ç—å / –º–∏–≥–∞–Ω–∏–µ
    if (deathAnimation) {
      deathTimer++;
      if (deathTimer % 10 === 0) blinkState = !blinkState;
      if (deathTimer > 60) {
        deathAnimation = false;
        gameOver = true;
        restartButton.style.display = 'inline-block';
      }
      return;
    }

    // –¥–≤–∏–∂–µ–Ω–∏–µ —Ñ–æ–Ω–∞
    bgX -= speed * bgSpeedFactor;
    if (bgX <= -canvas.width) bgX = 0;

    updateGround();

    player.vy += gravity;
    player.y += player.vy;
    if (player.y + player.size >= groundY) {
      player.y = groundY - player.size;
      player.vy = 0;
      player.onGround = true;
    }

    obstacles.forEach(o => o.x -= speed);
    spawnTimer--;
    if (spawnTimer <= 0) {
      spawnTimer = 60 + Math.floor(Math.random() * 80);
      spawnObstacle();
    }
    obstacles = obstacles.filter(o => o.x + o.w > -50);

    items.forEach(i => {
      i.x -= speed;
      i.phase += 0.05;
      i.y = i.baseY + Math.sin(i.phase) * 5;
    });

    itemTimer--;
    if (itemTimer <= 0) {
      itemTimer = 120 + Math.floor(Math.random() * 180);
      spawnItem();
    }
    items = items.filter(i => i.x + i.size > -50 && !i.caught);

    // —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
    for (let o of obstacles) {
      if (player.x < o.x + o.w &&
          player.x + player.size > o.x &&
          player.y + player.size > o.y) {
        deathAnimation = true;
        deathTimer = 0;
        blinkState = true;
        return;
      }
    }

    for (let i of items) {
      if (!i.caught &&
          player.x < i.x + i.size &&
          player.x + player.size > i.x &&
          player.y < i.y + i.size &&
          player.y + player.size > i.y) {
        i.caught = true;
        score += 1;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!gameStarted || canvas.height < 100) return;

    // —Ñ–æ–Ω
    if (bgImage.complete) {
      ctx.drawImage(bgImage, bgX, 0, canvas.width, canvas.height);
      ctx.drawImage(bgImage, bgX + canvas.width, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = '#dff0ff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // –∑–µ–º–ª—è
    ctx.fillStyle = '#cfcfcf';
    ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

    // –∏–≥—Ä–æ–∫
    let frameToDraw;
    if (!player.onGround) frameToDraw = playerFrames[0];
    else {
      frameTimer++;
      if (frameTimer >= frameDelay) {
        currentFrame = (currentFrame + 1) % 2;
        frameTimer = 0;
      }
      frameToDraw = playerFrames[currentFrame];
    }

    const scaleX = 1.2, scaleY = 1.0;
    const drawWidth = player.size * scaleX;
    const drawHeight = player.size * scaleY;

    if (blinkState && frameToDraw.complete)
      ctx.drawImage(frameToDraw, player.x, player.y - (drawHeight - player.size), drawWidth, drawHeight);

    ctx.fillStyle = '#b84';
    obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));

    items.forEach(i => {
      const img = itemSprites[i.spriteIndex];
      if (img.complete) ctx.drawImage(img, i.x, i.y, i.size, i.size);
      else {
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(i.x + i.size/2, i.y + i.size/2, i.size/2, 0, Math.PI*2);
        ctx.fill();
      }
    });

    ctx.fillStyle = '#000';
    ctx.font = '20px Arial';
    ctx.fillText('Score: ' + score, 12, canvas.height / 2 + 160);

    if (gameOver) {
      ctx.font = '36px Arial';
      ctx.fillText('GAME OVER', canvas.width/2 - 110, canvas.height/2);
      ctx.font = '16px Arial';
      ctx.fillText('–ù–∞–∂–º–∏ "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å" –∏–ª–∏ Enter', canvas.width/2 - 130, canvas.height/2 + 30);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();

  function restart() {
    obstacles = [];
    items = [];
    score = 0;
    speed = 6;
    spawnTimer = 60;
    itemTimer = 120;
    gameOver = false;
    deathAnimation = false;
    deathTimer = 0;
    blinkState = true;
    bgX = 0;
    updateGround();
    player.y = groundY - player.size;
    player.vy = 0;
    player.onGround = true;
    restartButton.style.display = 'none';
  }

  function startGame() {
    mainMenu.style.display = 'none';
    restartButton.style.display = 'none';
    score = 0;
    obstacles = [];
    items = [];
    bgX = 0;
    player.y = groundY - player.size;
    player.vy = 0;
    player.onGround = true;
    gameStarted = true;
  }

  startButton.addEventListener('click', startGame);
  restartButton.addEventListener('click', restart);
</script>
</body>
</html>
